# 3.3. Операционные системы, лекция 1 — Алексей Храпов

> 1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`. Обратите внимание, что `strace` выдаёт результат своей работы в поток stderr, а не в stdout.

В предложенном варианте `cd` делает следующий вызов: `chdir("/tmp")`

> 2. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:
> ```bash
> vagrant@netology1:~$ file /dev/tty
> /dev/tty: character special (5/0)
> vagrant@netology1:~$ file /dev/sda
> /dev/sda: block special (8/0)
> vagrant@netology1:~$ file /bin/bash
> /bin/bash: ELF 64-bit LSB shared object, x86-64
> ```
> Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.

Исходя из вывода `strace file` (`openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`) база данных `file` расположена по следующему пути: `/usr/share/misc/magic.mgc`

> 3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

Экспериментировал с `vi`:
```bash
vagrant@vagrant:~$ rm -f .test.swp
vagrant@vagrant:~$ ps -a
    PID TTY          TIME CMD
  14229 pts/1    00:00:00 vi
  14232 pts/3    00:00:00 ps
vagrant@vagrant:~$ lsof -p 14229 | grep deleted
vi      14229 vagrant    3u   REG  253,0    12288 131084 /home/vagrant/.test.swp (deleted)
vagrant@vagrant:~$ echo '' > /proc/14229/fd/3
vagrant@vagrant:~$ lsof -p 14229 | grep deleted
vi      14229 vagrant    3u   REG  253,0        1 131084 /home/vagrant/.test.swp (deleted)
```

> 4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

Зомби-процессы не занимают памяти, но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя в частности и системы в целом.

> 5. В iovisor BCC есть утилита `opensnoop`:
>```bash
>root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
>/usr/sbin/opensnoop-bpfcc
>```
>На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).

```bash
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
root@vagrant:~# /usr/sbin/opensnoop-bpfcc
PID    COMM               FD ERR PATH
613    irqbalance          6   0 /proc/interrupts
613    irqbalance          6   0 /proc/stat
613    irqbalance          6   0 /proc/irq/20/smp_affinity
613    irqbalance          6   0 /proc/irq/0/smp_affinity
613    irqbalance          6   0 /proc/irq/1/smp_affinity
613    irqbalance          6   0 /proc/irq/8/smp_affinity
613    irqbalance          6   0 /proc/irq/12/smp_affinity
613    irqbalance          6   0 /proc/irq/14/smp_affinity
613    irqbalance          6   0 /proc/irq/15/smp_affinity
```

> 6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.

Системный вызов: `uname ()`

Цитата из `man 'uname(2)`:
>Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version,
       domainname}.

> 7. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    Есть ли смысл использовать в bash `&&`, если применить `set -e`?

`&&` - условный оператор, используя который, правая часть запускается только при условии успешной отработки левой
т.е. в конструкции `test -d /tmp/some_dir && echo Hi` `echo Hi` будет выполнено, только, если `stat()` вернет значение `0` 

`;`  - разделитель последовательных команд, т.е. правая часть выражения выполнится после левой при любых обстоятельствах.

Если применить `set -e` вместе с `&&` выполнение команд должно прекратиться, т.к. `set -e` прерывает сессию при любом ненулевом значении исполняемых команд, кроме последней. Поэтому я считаю, что в таком использовании смысла нет.

> 8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

`-e`  указывает оболочке выйти, если команда дает ненулевой статус выхода. Проще говоря, оболочка завершает работу при сбое команды.

`-x` печатает аргументы команды во время выполнения.

`-u` обрабатывает неустановленные или неопределенные переменные, за исключением специальных параметров, таких как подстановочные знаки (*) или «@», как ошибки во время раскрытия параметра.

`-o pipefail` возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0 для успешного выполнения команд.

Для сценария это даст более детальный вывод ошибок (логирование), а также завершит сценарий при наличии ошибок, на любом этапе выполнения, кроме завершающей команды.

> 9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

Наиболее часто встречаются статусы:
`S` (вариации: `S`, `Ss`, `Ss+`, `Ssl`) - cпящий: ожидает завершения события; 

`I` (вариации: `I`, `I<`) - неактивный поток ядра (процесс бездействуе);

Дополнительные символы:

- `s` лидер сеанса
- `+` принадлежность группа процессов переднего плана
- `l` многопоточный (с использованием CLONE_THREAD)
- `<` высокий приоритет